---
title: 时间复杂度表示法
date:2019-05-20 20:32:55
---

#	时间复杂度表示法

不使用具体数据,粗略的计算出算法的执行效率;
<!--more-->

##	大**O**表示法
*	先看一段代码
```go
func cal (n int ) int {
	i := 0
	sum := 0
	for ;i < n ; i++  {
		sum += i
	}
	return sum
}
```
* 从CPU角度来看,这些代码都是读数据 运算 写数据 ,这里把每一行代码运行时间都记为unit_time;
  
     1.第一行和第二行运行时间分别都是**1**个unit_time
     2. 第四行和第五行运行时间都为**n**个unit_time 这里记为**2n**个unit_time
     3. 所以这段代码的运行时间为**2n+2**个unit_time
     4. 可以看出来所有的代码的执行时间**T(n)**与每行代码执行的次数成正比 
    
*	在看以下一段代码

```go
func cal (n int ) int {
	i := 0
	j := 0
	sum := 0
	for ;i < n ; i++  {
		j = 1
		for ;j < n ;j++  {
			sum += i+j
		}
	}
	return sum
}
```

*	这里每行代码运行时间单位还是unit_time
	1.第2,3,4行都是1一个unit_time,即3个unit_time
	
	2.5,6行分别都是n个unit_time,即2n个unit_time
	
	3.7,8行分别都是n个unit_time,即n²个unit_time
	
	4.最后得出结果是**2n+2n²+3**个unit_time
	
*	从这两段代码都是可以看出来,程序运行时间(**T(n)**)的都是与执行的代码行数**n**成正比
*	得出来的公式为 T(n) = O(f(n))
	T(n)表示代码执行的时间,n表示数据规模的大小,f(n)标识每行代码执行的次数总和;公式中的O表示代码的执行时间T(n)和f(n)表达式成正比
	第一个例子的结果为 T(n) = O(2n+2) 第二个例子结果为T(n) = O(2n²+2n+3),这个就是**大O时间复杂度表示法**,大O表示法并不能很精确的计算出代码真正的执行时间,只是能表示出来**代码执行时间随着数据规模的增长而增长**,所以也称为**渐进时间复杂度**,简称**时间复杂度**;
	公式中的低阶 常量 系数都不会左右T(n)的大小,所以这里只需要记录一个最大的数据量,以上的例子公式就可以简写为 1.T(n) = O(n) 2. T(n) = O(n²);
	
	
## 时间复杂度分析
1.只关注**循环执行次数最多**的一段代码,表示为O(n);
2.加法法则:总复杂度等于**量级最大**的那段代码的复杂度 如果是O(n²)+O(n³)那么结果就是T(n) = O(max(O(n²),O(n³));
3.乘法法则:嵌套代码的复杂度等于嵌套内外代码复杂度的乘积,如果是 T1(n) = O(n) T2(n) = O(n) 那么结果就是 T(n)=O(n²)



## 常见的时间复杂度
1.**O**(1) 
	一般情况下,只要算法中不存在递归,循环,这段代码的时间复杂度就是**O**(1);
2.**O**(logn) **O**(nlogn)
	对数阶时间复杂度比较难	

~~~go
for ;; {
	i++
	i *= 2
	if i > Count {
		break
	}	
}
~~~



